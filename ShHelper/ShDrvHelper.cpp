#include <ShDrvInc.h>

/**
 * @file ShDrvHelper.cpp
 * @author Shh0ya (hunho88@gmail.com)
 * @brief Driver entry
 * @date 2022-12-30
 * @copyright the GNU General Public License v3
 */

PSH_GLOBAL_ROUTINES      g_Routines;  /**< Global routines */
PSH_GLOBAL_VARIABLES     g_Variables; /**< Global variables */
PSH_GLOBAL_OFFSETS       g_Offsets;   /**< Global offsets data */
PSH_POOL_INFORMATION     g_Pools;     /**< Global pool manager */
PSH_GLOBAL_CALLBACKS     g_Callbacks; /**< Global callback manager */
PSH_GLOBAL_SOCKETS       g_Sockets;   /**< Global socket manager */


// LLVM is not support
//#pragma alloc_text("INIT", DriverEntry)

/**
* @brief Driver Entry
* @details Initialize global variable and major functions
* @param[in] PDRIVER_OBJECT `DriverObject`
* @param[in] PUNICODE_STRING `RegistryPath`
* @return If succeeds, return `STATUS_SUCCESS`, if fails return `STATUS_UNSUCCESSFUL`
* @author Shh0ya @date 2022-12-27
*/
NTSTATUS DriverEntry(
	IN PDRIVER_OBJECT DriverObject, 
	IN PUNICODE_STRING RegistryPath)
{
#if TRACE_LOG_DEPTH & TRACE_ENTRY
#if _CLANG
	TraceLog(__PRETTY_FUNCTION__, __FUNCTION__);
#else
	TraceLog(__FILE__, __FUNCTION__, __LINE__);
#endif
#endif
	SAVE_CURRENT_COUNTER;
	auto Status = STATUS_SUCCESS;

	ShDrvProcess* Process = nullptr;
	PSTR DestBuff = nullptr;

	for (auto i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++) { DriverObject->MajorFunction[i] = ShDrvMjFunction::DispatchRoutine; }
	DriverObject->DriverUnload = HelperFinalize;

	Status = DriverInitialize();
	if (!NT_SUCCESS(Status)) { ShDrvPoolManager::Finalize(); ERROR_END }

	Status = DeviceInitialize(DriverObject);
	if (!NT_SUCCESS(Status)) { ShDrvPoolManager::Finalize(); ERROR_END }
	
	Status = MiniFilterInitialize(DriverObject);
	if (!NT_SUCCESS(Status)) { ShDrvPoolManager::Finalize(); ERROR_END }

	Status = ObCallbackInitialize(DriverObject);
	if (!NT_SUCCESS(Status)) 
	{ 
		MiniFilterUnload(); 
		ShDrvPoolManager::Finalize(); 
		ERROR_END 
	}

	Status = NotifyRoutineInitialize();
	if (!NT_SUCCESS(Status))
	{
		CallbackFinalize();
		MiniFilterUnload();
		ShDrvPoolManager::Finalize();
		ERROR_END
	}
	
	ShDrvExample::MemoryScanTest();
	ShDrvExample::PeTest((HANDLE)9848, (HANDLE)2584);
	ShDrvExample::ProcessTest((HANDLE)9848);
	ShDrvExample::ProcessTest32((HANDLE)2584);
	ShDrvExample::SocketTest("192.168.0.3", "Hello?name=Shh0ya", "", "", GET);
	ShDrvExample::SocketTest("192.168.0.3", "Hello", "", "Name=Shh0ya", POST);

FINISH:
	PRINT_ELAPSED;
	return Status;
}

/**
* @brief Driver Unload
* @details Clean to allocated pool and generated information
* @param[in] PDRIVER_OBJECT `DriverObject`
* @return VOID
* @author Shh0ya @date 2022-12-27
*/
VOID HelperFinalize(
	IN PDRIVER_OBJECT DriverObject)
{
#if TRACE_LOG_DEPTH & TRACE_ENTRY
#if _CLANG
	TraceLog(__PRETTY_FUNCTION__, __FUNCTION__);
#else
	TraceLog(__FILE__, __FUNCTION__, __LINE__);
#endif
#endif
	SAVE_CURRENT_COUNTER;
	UNICODE_STRING LinkName = { 0, };

	CallbackFinalize();

	SharedMemoryFinalize();

	ShSocketAPI::WskCleanup();

	if (g_Variables->DeviceObject != nullptr)
	{
		RtlInitUnicodeString(&LinkName, SYMBOLIC_NAME);
		IoDeleteDevice(g_Variables->DeviceObject);
		IoDeleteSymbolicLink(&LinkName);
	}

	ShDrvPoolManager::Finalize();

	Log("Driver unload");

	PRINT_ELAPSED;
}

/**
* @brief [MACRO] Set module base address and end address
* @details if the value is not set, call ERROR_END
* @param[in] PCSTR `ModuleName`
* @param[in] `MemberName`
* @author Shh0ya @date 2022-12-27
* @see DriverInitialize
*/
#define INIT_BASEADDRESS(Module,Member)\
g_Variables->Member##BaseAddress = ShDrvCore::GetKernelBaseAddress(Module, &ImageSize, LoadedModuleList);\
g_Variables->Member##EndAddress = ADD_OFFSET(g_Variables->Member##BaseAddress, ImageSize, PVOID);\
if(g_Variables->Member##BaseAddress == nullptr || g_Variables->Member##BaseAddress == g_Variables->Member##EndAddress) { Status = STATUS_NOT_SUPPORTED; ERROR_END }

/**
* @brief Driver Initialize
* @details Initialize pool manager, global variables, global routines and global offsets
* @return If succeeds, return `STATUS_SUCCESS`, if fails return `STATUS_NOT_SUPPORTED`
* @author Shh0ya @date 2022-12-27
* @see GET_GLOBAL_POOL, INIT_BASEADDRESS, GET_EXPORT_VARIABLE, GET_EXPORT_ROUTINE
*/
NTSTATUS DriverInitialize()
{
#if TRACE_LOG_DEPTH & TRACE_ENTRY
#if _CLANG
	TraceLog(__PRETTY_FUNCTION__, __FUNCTION__);
#else
	TraceLog(__FILE__, __FUNCTION__, __LINE__);
#endif
#endif
	SAVE_CURRENT_COUNTER;
	auto Status = STATUS_SUCCESS;
	ULONG64 ImageSize = 0;
	
	Status = ShDrvPoolManager::Initialize();
	if (!NT_SUCCESS(Status)) 
	{
		ShDrvPoolManager::Finalize();
		ERROR_END 
	}

	GET_GLOBAL_POOL(g_Routines, GLOBAL_ROUTINES);
	GET_GLOBAL_POOL(g_Variables, GLOBAL_VARIABLES);
	GET_GLOBAL_POOL(g_Offsets, GLOBAL_OFFSETS);
	GET_GLOBAL_POOL(g_Callbacks, GLOBAL_CALLBACKS);
	GET_GLOBAL_POOL(g_Sockets, GLOBAL_SOCKETS);

	g_Sockets->Dispatch.Version = MAKE_WSK_VERSION(1, 0);

	g_Variables->KUserSharedData = reinterpret_cast<PKUSER_SHARED_DATA>(KUSER_SHARED_DATA_ADDRESS);
	g_Variables->BuildNumber = g_Variables->KUserSharedData->NtBuildNumber;
	
	g_Variables->SystemDirBase = __readcr3();

	INIT_BASEADDRESS("ntoskrnl.exe", System);
	INIT_BASEADDRESS("win32k.sys", Win32k);
	INIT_BASEADDRESS("win32kbase.sys", Win32kBase);
	INIT_BASEADDRESS("win32kfull.sys", Win32kFull);
	INIT_BASEADDRESS("cdd.dll", Cdd);
	INIT_BASEADDRESS("ci.dll", Ci);

	GET_EXPORT_VARIABLE(PsLoadedModuleList, PLIST_ENTRY);
	GET_EXPORT_VARIABLE(PsLoadedModuleResource, PERESOURCE);

	if (!NT_SUCCESS(Status)) { Status = STATUS_NOT_SUPPORTED; ERROR_END }

	Status = InitializeOffset_Unsafe();
	if (!NT_SUCCESS(Status)) { ERROR_END }

	GET_EXPORT_ROUTINE(PsGetProcessImageFileName, Ps);
	GET_EXPORT_ROUTINE(PsGetProcessPeb, Ps);
	GET_EXPORT_ROUTINE(PsGetProcessWow64Process, Ps);
	GET_EXPORT_ROUTINE(ObGetObjectType, Ob);
	GET_EXPORT_ROUTINE(PsReferenceProcessFilePointer, Ps);

	if (!NT_SUCCESS(Status)) { Status = STATUS_NOT_SUPPORTED; ERROR_END }

FINISH:
	PRINT_ELAPSED;
	return Status;
}

/**
* @brief Initialize Offsets
* @warning This routine is unsafely. The symbol or other method(pattern scan, etc...) must be used
* Otherwise, must be checked if it's validate.
* @details Initialize offset value
* @return If succeeds, return `STATUS_SUCCESS`, if fails `NTSTATUS` value, not `STATUS_SUCCESS`
* @author Shh0ya @date 2022-12-27
*/
NTSTATUS InitializeOffset_Unsafe()
{
#if TRACE_LOG_DEPTH & TRACE_ENTRY
#if _CLANG
	TraceLog(__PRETTY_FUNCTION__, __FUNCTION__);
#else
	TraceLog(__FILE__, __FUNCTION__, __LINE__);
#endif
#endif
	
	SAVE_CURRENT_COUNTER;
	auto Status = STATUS_INVALID_PARAMETER;
	if(g_Offsets == nullptr || g_Variables == nullptr) { ERROR_END }

	switch (g_Variables->BuildNumber)
	{
	case WINDOWS_7:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0xDC);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0xE0);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x160);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x180);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x188);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x218);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x288);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x338);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x200);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x1f0);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x320);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x308);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x328);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x444);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x448);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x278);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x50);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xb8);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x164);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x210);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x388);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x3b0);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x410);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x420);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x438);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x448);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x44c);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x378);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0);
		break;
	}
	case WINDOWS_7_SP1:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0xDC);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0xE0);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x160);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x180);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x188);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x218);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x288);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x338);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x200);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x1f0);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x320);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x308);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x328);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x444);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x448);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x278);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x50);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xb8);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x164);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x210);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x388);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x3b0);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x410);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x420);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x438);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x448);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x44c);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x378);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0);
		break;
	}
	case WINDOWS_8:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x234);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x238);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x2c8);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x2e0);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x2e8);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x358);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x3c8);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x3e8);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x408);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x410);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x418);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x470);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x480);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x58c);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x590);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x630);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x370);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x398);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x3f0);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x400);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x418);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x42c);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x430);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x450);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0);
		break;
	}
	case WINDOWS_8_1:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x234);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x238);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x2c8);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x2e0);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x2e8);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x358);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x3c8);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x3e8);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x408);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x410);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x418);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x470);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x480);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x5d4);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x5d8);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x660);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x5f8);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x620);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x678);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x688);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x6a0);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x6b4);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x6b8);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x6d8);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x760);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x768);
		break;
	}
	case WINDOWS_10_1507:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x23c);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x240);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x2d8);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x2e8);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x2f0);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x368);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x3d8);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x3f8);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x418);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x420);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x428);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x480);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x490);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x604);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x608);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x690);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x600);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x628);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x680);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x690);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x6a8);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x6bc);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x6c0);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x6e0);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x790);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x798);
		break;
	}
	case WINDOWS_10_1511:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x23c);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x240);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x2d8);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x2e8);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x2f0);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x368);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x3d8);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x3f8);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x418);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x420);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x428);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x488);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x498);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x60c);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x610);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x698);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x600);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x628);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x680);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x690);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x6a8);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x6bc);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x6c0);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x6e0);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x790);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x798);
		break;
	}
	case WINDOWS_10_1607:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x23c);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x240);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x2d8);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x2e8);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x2f0);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x368);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x3d8);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x3f8);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x418);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x420);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x428);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x488);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x498);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x61c);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x620);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x6a8);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x608);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x630);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x688);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x698);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x6b0);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x6c0);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x6c4);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x6f0);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x798);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x7a0);
		break;
	}
	case WINDOWS_10_1703:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x23c);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x240);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x2d8);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x2e0);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x2e8);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x368);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x3d8);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x3f8);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x418);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x420);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x428);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x488);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x498);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x624);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x628);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x6b0);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x610);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x638);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x690);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x6a0);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x6b8);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x6c8);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x6cc);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x6f8);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x7a0);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x7a8);
		break;
	}
	case WINDOWS_10_1709:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x23c);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x240);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x2d8);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x2e0);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x2e8);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x368);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x3d8);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x3f8);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x418);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x420);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x428);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x488);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x498);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x624);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x628);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x6b0);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x610);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x638);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x690);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x6a8);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x6c0);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x6d0);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x6d4);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x700);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x7a8);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x7b0);
		break;
	}
	case WINDOWS_10_1803:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x23c);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x240);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0x278);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x2d8);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x2e0);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x2e8);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x368);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x3d8);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x3f8);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x418);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x420);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x428);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x488);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x498);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x624);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x628);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x6b0);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x610);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x638);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x690);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x6a8);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x6c0);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x6d0);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x6d4);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x700);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x7a8);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x7b0);
		break;
	}
	case WINDOWS_10_1809:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x23c);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x240);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0x278);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x2d8);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x2e0);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x2e8);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x368);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x3d8);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x3f8);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x418);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x420);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x428);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x488);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x498);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x624);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x628);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x6b0);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x610);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x638);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x690);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x6a8);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x6c0);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x6d0);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x6d4);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x700);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x7a0);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x7a8);
		break;
	}
	case WINDOWS_10_1903:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x240);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x248);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0x280);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x2e0);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x2e8);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x2f0);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x370);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x3e0);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x3f8);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x418);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x420);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x428);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x488);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x498);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x654);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x658);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x6e0);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x620);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x648);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x6a0);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x6b8);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x6d0);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x6e0);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x6e4);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x710);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x7b0);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x7b8);
		break;
	}
	case WINDOWS_10_1909:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x240);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x248);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0x280);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x2e0);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x2e8);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x2f0);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x370);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x3e0);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x3f8);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x418);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x420);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x428);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x488);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x498);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x654);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x658);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x6e0);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x620);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x648);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x6a0);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x6b8);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x6d0);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x6e0);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x6e4);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x710);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x7b0);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x7b8);
		break;
	}
	case WINDOWS_10_20H1:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x348);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x350);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0x388);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x438);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x440);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x448);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x4c8);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x538);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x550);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x570);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x578);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x580);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x5e0);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x5f0);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x7d4);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x7d8);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x860);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x450);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x478);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x4d0);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x4e8);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x500);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x510);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x514);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x548);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x5e8);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x5f0);
		break;
	}
	case WINDOWS_10_20H2:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x348);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x350);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0x388);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x438);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x440);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x448);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x4c8);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x538);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x550);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x570);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x578);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x580);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x5e0);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x5f0);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x7d4);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x7d8);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x860);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x450);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x478);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x4d0);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x4e8);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x500);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x510);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x514);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x548);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x5e8);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x5f0);
		break;
	}
	case WINDOWS_10_21H1:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x348);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x350);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0x388);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x438);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x440);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x448);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x4c8);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x538);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x550);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x570);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x578);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x580);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x5e0);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x5f0);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x7d4);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x7d8);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x860);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x450);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x478);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x4d0);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x4e8);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x500);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x510);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x514);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x548);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x5e8);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x5f0);
		break;
	}
	case WINDOWS_10_21H2:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x348);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x350);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0x388);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x438);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x440);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x448);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x4c8);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x538);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x550);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x570);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x578);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x580);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x5e0);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x5f0);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x7d4);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x7d8);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x860);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x450);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x478);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x4d0);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x4e8);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x500);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x510);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x514);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x548);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x5e8);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x5f0);
		break;
	}
	case WINDOWS_10_22H2:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x348);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x350);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0x388);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x438);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x440);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x448);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x4c8);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x538);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x550);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x570);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x578);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x580);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x5e0);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x5f0);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x7d4);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x7d8);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x860);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x450);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x478);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x4d0);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x4e8);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x500);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x510);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x514);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x548);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x5e8);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x5f0);
		break;
	}
	case WINDOWS_11_21H2:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x348);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x350);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0x388);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x438);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x440);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x448);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x4c8);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x538);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x550);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x570);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x578);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x580);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x5e0);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x5f0);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x7d4);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x7d8);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x860);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x4a0);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x4c8);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x520);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x538);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x550);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x560);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x564);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x598);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x638);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x640);
		break;
	}
	case WINDOWS_11_22H2:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x348);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x350);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0x388);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x438);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x440);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x448);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x4c8);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x538);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x550);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x570);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x578);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x580);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x5e0);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x5f0);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x7d4);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x7d8);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x860);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x4a0);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x4c8);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x520);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x538);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x550);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x560);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x564);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x598);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x638);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x640);
		break;
	}
	default:
	{
		Status = STATUS_NOT_SUPPORTED;
		break;
	}
	}

	Status = STATUS_SUCCESS;

FINISH:
	PRINT_ELAPSED;
	return Status;
}

/**
* @brief Initialize device
* @details Initialize device object and symbolic link
* @param[in] PDRIVER_OBJECT `DriverObject`
* @return If succeeds, return `STATUS_SUCCESS`, if fails `NTSTATUS` value, not `STATUS_SUCCESS`
* @author Shh0ya @date 2022-12-27
*/
NTSTATUS DeviceInitialize(
	IN PDRIVER_OBJECT DriverObject)
{
#if TRACE_LOG_DEPTH & TRACE_ENTRY
#if _CLANG
	TraceLog(__PRETTY_FUNCTION__, __FUNCTION__);
#else
	TraceLog(__FILE__, __FUNCTION__, __LINE__);
#endif
#endif

	SAVE_CURRENT_COUNTER;
	auto Status = STATUS_INVALID_PARAMETER;
	PDEVICE_OBJECT DeviceObject = nullptr;
	UNICODE_STRING DeviceName = { 0, };
	UNICODE_STRING LinkName = { 0, };

	RtlInitUnicodeString(&DeviceName, DEVICE_NAME);
	RtlInitUnicodeString(&LinkName, SYMBOLIC_NAME);

	Status = IoCreateDevice(DriverObject, 0, &DeviceName, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &DeviceObject);
	if (!NT_SUCCESS(Status)) { ERROR_END }

	Status = IoCreateSymbolicLink(&LinkName, &DeviceName);
	if (NT_SUCCESS(Status) == FALSE) { ERROR_END }

	g_Variables->DeviceObject = DeviceObject;

FINISH:
	PRINT_ELAPSED;
	return Status;
}

/**
* @brief Set `Mini-Filter` registry value
* @details Sets the registry value required for `Mini-Filter` registration
* @return If succeeds, return `STATUS_SUCCESS`, if fails `NTSTATUS` value, not `STATUS_SUCCESS`
* @author Shh0ya @date 2022-12-27
*/
NTSTATUS SetFltRegistry()
{
#if TRACE_LOG_DEPTH & TRACE_ENTRY
#if _CLANG
	TraceLog(__PRETTY_FUNCTION__, __FUNCTION__);
#else
	TraceLog(__FILE__, __FUNCTION__, __LINE__);
#endif
#endif

	SAVE_CURRENT_COUNTER;
	auto Status = STATUS_INVALID_PARAMETER;
	ShDrvCore::ShString RegistryPath;

	RegistryPath = REGISTRY_HKLM_SERVICE;
	RegistryPath += "ShHelper\\Instances";

	Status = ShDrvUtil::RegCreateKey(RegistryPath.GetString());
	if (!NT_SUCCESS(Status)) { ERROR_END }

	Status = ShDrvUtil::RegSetStr(RegistryPath.GetString(), "DefaultInstance", L"ShHelper Filter Instance");
	if (!NT_SUCCESS(Status)) { ERROR_END }

	RegistryPath += "\\ShHelper Filter Instance";
	Status = ShDrvUtil::RegCreateKey(RegistryPath.GetString());
	if (!NT_SUCCESS(Status)) { ERROR_END }

	Status = ShDrvUtil::RegSetStr(RegistryPath.GetString(), "Altitude", L"390000");
	if (!NT_SUCCESS(Status)) { ERROR_END }

	Status = ShDrvUtil::RegSetDword(RegistryPath.GetString(), "Flags", 0);
	if (!NT_SUCCESS(Status)) { ERROR_END }

FINISH:
	PRINT_ELAPSED;
	return Status;
}

/**
* @brief Initialize `Mini-Filter`
* @details Load the `Mini-Filter`
* @param[in] PDRIVER_OBJECT `DriverObject`
* @return If succeeds, return `STATUS_SUCCESS`, if fails `NTSTATUS` value, not `STATUS_SUCCESS`
* @author Shh0ya @date 2022-12-27
*/
NTSTATUS MiniFilterInitialize(
	IN PDRIVER_OBJECT DriverObject)
{
#if TRACE_LOG_DEPTH & TRACE_ENTRY
#if _CLANG
	TraceLog(__PRETTY_FUNCTION__, __FUNCTION__);
#else
	TraceLog(__FILE__, __FUNCTION__, __LINE__);
#endif
#endif

	SAVE_CURRENT_COUNTER;
	auto Status = STATUS_INVALID_PARAMETER;
	PFLT_FILTER Filter = nullptr;
	PSECURITY_DESCRIPTOR SecurityDescriptor = { 0, };
	OBJECT_ATTRIBUTES ObjAttrib = { 0, };
	UNICODE_STRING PortString = { 0, };

	FLT_CONTEXT_REGISTRATION ContextRegistration[] = {
		{
			FLT_STREAMHANDLE_CONTEXT,
			0,
			nullptr,
			sizeof(BOOLEAN),
			'ShFt'},
		{FLT_CONTEXT_END}
	};

	FLT_REGISTRATION FilterRegistration = {
		sizeof(FLT_REGISTRATION),
		FLT_REGISTRATION_VERSION,
		0,
		ContextRegistration,
		MiniFilterCallbacks,
		ShMiniFilter::MiniFilterUnload,
		ShMiniFilter::MiniFilterInstanceSetup,
		ShMiniFilter::MiniFilterInstanceQueryTeardown,
		nullptr, // InstanceTeardownStartCallback
		nullptr, // InstanceTeardownCompleteCallback
		nullptr, // GenerateFileNameCallback
		nullptr, // NormalizeNameComponentCallback
		nullptr, // NormalizeContextCleanupCallback
		nullptr, // TransactionNotificationCallback
		nullptr, // NormalizeNameComponentExCallback
		nullptr  // SectionNotificationCallback
	};

	RtlInitUnicodeString(&PortString, MINIFILTER_PORT);
	
	Status = SetFltRegistry();
	if(!NT_SUCCESS(Status)) { ERROR_END }

	Status = FltRegisterFilter(DriverObject, &FilterRegistration, &Filter);
	if (!NT_SUCCESS(Status)) { ERROR_END }

	Status = FltBuildDefaultSecurityDescriptor(&SecurityDescriptor, FLT_PORT_ALL_ACCESS);
	if(!NT_SUCCESS(Status)) 
	{ 
		FltUnregisterFilter(Filter); 
		ERROR_END 
	}

	InitializeObjectAttributes(
		&ObjAttrib, 
		&PortString, 
		OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, 
		nullptr, 
		SecurityDescriptor);

	Status = FltCreateCommunicationPort(
		Filter,
		&g_Callbacks->ServerPort,
		&ObjAttrib,
		nullptr,
		ShMiniFilter::MiniFilterConnect,
		ShMiniFilter::MiniFilterDisconnect,
		ShMiniFilter::MiniFilterMessage,
		1
	);
	if (!NT_SUCCESS(Status)) 
	{ 
		FltFreeSecurityDescriptor(SecurityDescriptor);
		FltUnregisterFilter(Filter); 
		ERROR_END
	}

	Status = FltStartFiltering(Filter);
	if (!NT_SUCCESS(Status)) 
	{
		FltCloseCommunicationPort(g_Callbacks->ServerPort);
		FltFreeSecurityDescriptor(SecurityDescriptor);
		FltUnregisterFilter(Filter);
		ERROR_END 
	}

	g_Callbacks->Filter = Filter;
	Log("Mini-filter initialization completed");

FINISH:
	PRINT_ELAPSED;
	return Status;
}

/**
* @brief Initialize `Object Callbacks`
* @details Set the `Object Callbacks`
* @param[in] PDRIVER_OBJECT `DriverObject`
* @return If succeeds, return `STATUS_SUCCESS`, if fails `NTSTATUS` value, not `STATUS_SUCCESS`
* @author Shh0ya @date 2022-12-27
*/
NTSTATUS ObCallbackInitialize(
	IN PDRIVER_OBJECT DriverObject)
{
#if TRACE_LOG_DEPTH & TRACE_ENTRY
#if _CLANG
	TraceLog(__PRETTY_FUNCTION__, __FUNCTION__);
#else
	TraceLog(__FILE__, __FUNCTION__, __LINE__);
#endif
#endif

	SAVE_CURRENT_COUNTER;
	auto Status = STATUS_INVALID_PARAMETER;
	auto Section = reinterpret_cast<LDR_DATA_TABLE_ENTRY*>(DriverObject->DriverSection);
	Section->Flags |= 0x20;

	OB_CALLBACK_REGISTRATION  CallbackRegistration = { 0, };
	OB_OPERATION_REGISTRATION OperationRegistration[2] = { 0, };

	OperationRegistration[0].ObjectType    = PsProcessType;
	OperationRegistration[0].Operations    = OB_OPERATION_HANDLE_CREATE;
	OperationRegistration[0].PreOperation  = ObjectCallbacks::ProcessPreOperationCallback;
	OperationRegistration[0].PostOperation = ObjectCallbacks::ProcessPostOperationCallback;
	
	OperationRegistration[1].ObjectType    = PsThreadType;
	OperationRegistration[1].Operations    = OB_OPERATION_HANDLE_CREATE;
	OperationRegistration[1].PreOperation  = ObjectCallbacks::ThreadPreOperationCallback;
	OperationRegistration[1].PostOperation = ObjectCallbacks::ThreadPostOperationCallback;

	RtlInitUnicodeString(&CallbackRegistration.Altitude, L"397000");
	CallbackRegistration.Version = ObGetFilterVersion();
	CallbackRegistration.OperationRegistrationCount = 2;
	CallbackRegistration.OperationRegistration = OperationRegistration;
	
	Status = ObRegisterCallbacks(&CallbackRegistration, &g_Callbacks->CallbackRegistration);
	if (!NT_SUCCESS(Status)) { ERROR_END }

FINISH:
	PRINT_ELAPSED;
	return Status;
}

/**
* @brief Initialize `Notify routines`
* @details Set the `Notify routines`
* @return If succeeds, return `STATUS_SUCCESS`, if fails `NTSTATUS` value, not `STATUS_SUCCESS`
* @author Shh0ya @date 2022-12-27
*/
NTSTATUS NotifyRoutineInitialize()
{
#if TRACE_LOG_DEPTH & TRACE_ENTRY
#if _CLANG
	TraceLog(__PRETTY_FUNCTION__, __FUNCTION__);
#else
	TraceLog(__FILE__, __FUNCTION__, __LINE__);
#endif
#endif

	SAVE_CURRENT_COUNTER;
	auto Status = STATUS_INVALID_PARAMETER;

	Status = PsSetCreateProcessNotifyRoutine(NotifyRoutines::ProcessNotifyRoutine, FALSE);
	if (!NT_SUCCESS(Status)) { ERROR_END }
	g_Callbacks->bProcessNotify = TRUE;

	Status = PsSetCreateProcessNotifyRoutineEx(NotifyRoutines::ProcessNotifyRoutineEx, FALSE);
	if (!NT_SUCCESS(Status)) { ERROR_END }
	g_Callbacks->bProcessNotifyEx = TRUE;

	Status = PsSetCreateThreadNotifyRoutine(NotifyRoutines::ThreadNotifyRoutine);
	if (!NT_SUCCESS(Status)) { ERROR_END }
	g_Callbacks->bThreadNotify = TRUE;

	Status = PsSetLoadImageNotifyRoutine(NotifyRoutines::LoadImageNotifyRoutine);
	if (!NT_SUCCESS(Status)) { ERROR_END }
	g_Callbacks->bImageNotify = TRUE;

FINISH:
	PRINT_ELAPSED;
	return Status;
}

/**
* @brief Finalize `Object Callbacks` & `Notify routines`
* @details Remove all callbacks
* @author Shh0ya @date 2022-12-27
*/
VOID CallbackFinalize()
{
#if TRACE_LOG_DEPTH & TRACE_ENTRY
#if _CLANG
	TraceLog(__PRETTY_FUNCTION__, __FUNCTION__);
#else
	TraceLog(__FILE__, __FUNCTION__, __LINE__);
#endif
#endif
	SAVE_CURRENT_COUNTER;

	if (g_Callbacks->CallbackRegistration != nullptr) { ObUnRegisterCallbacks(g_Callbacks->CallbackRegistration); }
	if (g_Callbacks->bProcessNotify) { PsSetCreateProcessNotifyRoutine(NotifyRoutines::ProcessNotifyRoutine, TRUE); }
	if (g_Callbacks->bProcessNotifyEx) { PsSetCreateProcessNotifyRoutineEx(NotifyRoutines::ProcessNotifyRoutineEx, TRUE); }
	if (g_Callbacks->bProcessNotify) { PsRemoveCreateThreadNotifyRoutine(NotifyRoutines::ThreadNotifyRoutine); }
	if (g_Callbacks->bProcessNotify) { PsRemoveLoadImageNotifyRoutine(NotifyRoutines::LoadImageNotifyRoutine); }

FINISH:
	PRINT_ELAPSED;
}

/**
* @brief Finalize `Mini-Filter`
* @details Unload mini filter
* @author Shh0ya @date 2022-12-27
*/
VOID MiniFilterUnload()
{
#if TRACE_LOG_DEPTH & TRACE_ENTRY
#if _CLANG
	TraceLog(__PRETTY_FUNCTION__, __FUNCTION__);
#else
	TraceLog(__FILE__, __FUNCTION__, __LINE__);
#endif
#endif
	SAVE_CURRENT_COUNTER;

	FltCloseCommunicationPort(g_Callbacks->ServerPort);
	FltUnregisterFilter(g_Callbacks->Filter);

FINISH:
	PRINT_ELAPSED;
}

/**
* @brief Finalize shared memory
* @author Shh0ya @date 2022-12-27
*/
VOID SharedMemoryFinalize()
{
#if TRACE_LOG_DEPTH & TRACE_ENTRY
#if _CLANG
	TraceLog(__PRETTY_FUNCTION__, __FUNCTION__);
#else
	TraceLog(__FILE__, __FUNCTION__, __LINE__);
#endif
#endif
	SAVE_CURRENT_COUNTER;

	auto SharedData1 = &g_Variables->SharedData1;
	auto SharedData2 = &g_Variables->SharedData2;
	if (SharedData1->Data != nullptr)
	{
		MmUnmapLockedPages(SharedData1->MappedPhysicalAddress, SharedData1->MappedPhysicalMDL);
		MmUnmapLockedPages(SharedData1->MappedVirtualAddress, SharedData1->MappedVirtualMDL);
		MmFreePagesFromMdl(SharedData1->MappedPhysicalMDL);
		IoFreeMdl(SharedData1->MappedVirtualMDL);
		FREE_POOLEX(SharedData1->MappedPhysicalMDL);
	}

	if (SharedData2->Data != nullptr)
	{
		MmUnmapLockedPages(SharedData2->MappedPhysicalAddress, SharedData2->MappedPhysicalMDL);
		MmUnmapLockedPages(SharedData2->MappedVirtualAddress, SharedData2->MappedVirtualMDL);
		MmFreePagesFromMdl(SharedData2->MappedPhysicalMDL);
		IoFreeMdl(SharedData2->MappedVirtualMDL);
		FREE_POOLEX(SharedData2->MappedPhysicalMDL);
	}

FINISH:
	PRINT_ELAPSED;
}

VOID ShDrvExample::PeTest(
	IN HANDLE ProcessId, 
	IN HANDLE ProcessId32)
{
	PlainLog("======================== PE Sample =======================\n");
	//======================================================
	// Kernel Base
	//======================================================
	auto Pe = new(ShDrvPe);
	if (NT_SUCCESS(Pe->Initialize(g_Variables->SystemBaseAddress, PsInitialSystemProcess)))
	{
		Log("PE Test(Kernel Normal) %p", Pe->GetAddressByExport("ZwQuerySystemInformation"));
	}
	delete(Pe);

	//======================================================
	// Kernel Base(Session)
	//======================================================
	Pe = new(ShDrvPe);
	if (NT_SUCCESS(Pe->Initialize(g_Variables->Win32kBaseBaseAddress, PsInitialSystemProcess)))
	{
		Log("PE Test(Kernel Session) %p", Pe->GetAddressByExport("IsDwmApiPortRegistered"));
	}
	delete(Pe);

	//======================================================
	// Process Base(32)
	//======================================================
	Pe = new(ShDrvPe);
	auto Process = new(ShDrvProcess);
	LDR_DATA_TABLE_ENTRY32 LdrEntry32 = { 0, };
	if (NT_SUCCESS(Process->Initialize(ProcessId32)))
	{
		Process->GetProcessModuleInformation32("ntdll.dll", &LdrEntry32);
	}

	if (NT_SUCCESS(Pe->Initialize((PVOID)LdrEntry32.DllBase, Process->GetProcess(), TRUE)))
	{
		Log("PE Test(Process 32) %p", Pe->GetAddressByExport("NtQuerySystemInformation"));
	}
	delete(Process);
	delete(Pe);

	//======================================================
	// Process Base(64)
	//======================================================
	Pe = new(ShDrvPe);
	Process = new(ShDrvProcess);
	LDR_DATA_TABLE_ENTRY LdrEntry = { 0, };
	if (NT_SUCCESS(Process->Initialize(ProcessId)))
	{
		Process->GetProcessModuleInformation("ntdll.dll", &LdrEntry);
	}

	if (NT_SUCCESS(Pe->Initialize(LdrEntry.DllBase, Process->GetProcess())))
	{
		Log("PE Test(Process 64) %p", Pe->GetAddressByExport("NtQuerySystemInformation"));
	}
	delete(Process);
	delete(Pe);
}

VOID ShDrvExample::ProcessTest(
	IN HANDLE ProcessId)
{
	PlainLog("======================== Process Sample(x64) =======================\n");
	
	auto Process = new(ShDrvProcess);
	PVOID* Result = nullptr;
	PSTR LinkName = reinterpret_cast<PSTR>(ALLOC_POOL(ANSI_POOL));
	if (NT_SUCCESS(Process->Initialize(ProcessId)))
	{

		//======================================================
		// Process module 64
		//======================================================
		LDR_DATA_TABLE_ENTRY LdrEntry = { 0, };
		Process->GetProcessModuleInformation("ntdll.dll", &LdrEntry);

		//======================================================
		// Process read & write(physical) 64
		//======================================================
		USHORT ReadMagic = 0;
		USHORT AfterMagic = 0;
		USHORT WriteMagic = 0xffff;
		Process->ReadProcessMemory(LdrEntry.DllBase, 2, &ReadMagic);
		Process->WriteProcessMemory(LdrEntry.DllBase, 2, &WriteMagic, RW_Physical);
		Process->ReadProcessMemory(LdrEntry.DllBase, 2, &AfterMagic);
		Log("Original : %X, After : %X", ReadMagic, AfterMagic);
		Process->WriteProcessMemory(LdrEntry.DllBase, 2, &ReadMagic, RW_Physical);
		Log("%p %X", LdrEntry.DllBase, LdrEntry.SizeOfImage);

		//======================================================
        // Process Link Name
        //======================================================
		NTSTATUS Status = Process->GetProcessLinkName(LinkName);
		Log("Link Name : %s", LinkName);

		//======================================================
		// Process memory scan 64
		//======================================================
		Result = reinterpret_cast<PVOID*>(ALLOC_POOL(NONE_SPECIAL));
		ULONG ResultCount = 0;

		ResultCount = Process->MemoryScan(
			LdrEntry.DllBase,
			LdrEntry.SizeOfImage,
			"4C 8B D1 B8 ?? ?? ?? ?? F6 04 25 08 03 FE 7F 01 75 03 0F 05 C3",
			Result);

		/*ResultCount = Process->MemoryScan(
			LdrEntry.DllBase,
			".text",
			"4C 8B D1 B8 ?? ?? ?? ?? F6 04 25 08 03 FE 7F 01 75 03 0F 05 C3",
			Result,
			nullptr,
			TRUE);

		ResultCount = Process->MemoryScan(
			LdrEntry.DllBase,
			".text",
			"\x4c\x8b\xd1\xb8\x00\x00\x00\x00\xf6\x04\x25\x08\x03\xfe\x7f\x01\x75\x03\x0F\x05\xC3",
			&Result,
			"xxxx????xxxxxxxxxxxxx",
			TRUE);*/

		for (auto i = 0; i < ResultCount; i++)
		{
			Log("[%d] %p", i, Result[i]);
		}
	}
	delete(Process);
	FREE_POOL(Result);
	FREE_POOL(LinkName);
}

VOID ShDrvExample::ProcessTest32(
	IN HANDLE ProcessId32)
{
	PlainLog("======================== Process Sample(x86) =======================\n");
	auto Process = new(ShDrvProcess);
	PVOID* Result = nullptr;

	if (NT_SUCCESS(Process->Initialize((HANDLE)ProcessId32)))
	{
		//======================================================
		// Process module 32
		//======================================================
		LDR_DATA_TABLE_ENTRY32 LdrEntry32 = { 0, };
		Process->GetProcessModuleInformation32("ntdll.dll", &LdrEntry32);

		//======================================================
		// Process read & write(physical) 32
		//======================================================
		USHORT ReadMagic = 0;
		USHORT AfterMagic = 0;
		USHORT WriteMagic = 0xffff;
		Process->ReadProcessMemory((PVOID)LdrEntry32.DllBase, 2, &ReadMagic);
		Process->WriteProcessMemory((PVOID)LdrEntry32.DllBase, 2, &WriteMagic, RW_Physical);
		Process->ReadProcessMemory((PVOID)LdrEntry32.DllBase, 2, &AfterMagic);
		Log("Original : %X, After : %X", ReadMagic, AfterMagic);
		Process->WriteProcessMemory((PVOID)LdrEntry32.DllBase, 2, &ReadMagic, RW_Physical);
		Log("%p %X", LdrEntry32.DllBase, LdrEntry32.SizeOfImage);

		//======================================================
		// Process memory scan 32
		//======================================================
		Result = reinterpret_cast<PVOID*>(ALLOC_POOL(NONE_SPECIAL));
		ULONG ResultCount = 0;

		ResultCount = Process->MemoryScan(
			(PVOID)LdrEntry32.DllBase,
			LdrEntry32.SizeOfImage,
			"B8 ?? 00 00 00 BA 20 8F BE 77 FF D2 C2 ?? 00",
			Result);

		for (auto i = 0; i < ResultCount; i++)
		{
			Log("[%d] %p", i, Result[i]);
		}
	}
	delete(Process);
	FREE_POOL(Result);
}

VOID ShDrvExample::MemoryScanTest()
{
	PlainLog("======================== Memory Scanner(Kernel) Sample =======================\n");

	//======================================================
	// System address
	//======================================================
	auto Scanner = new(MemoryScanner);
	PVOID* Result = nullptr;
	if (NT_SUCCESS(Scanner->Initialize(g_Variables->SystemBaseAddress, ".text")))
	{
		Scanner->MakePattern("48 8B 81 ?? ?? ?? ?? C3");
		Scanner->Scan();

		Result = Scanner->GetScanResult();
		Log("%p", *Result);
	}
	delete(Scanner);

	//======================================================
	// Session address
	//======================================================
	Scanner = new(MemoryScanner);

	if (NT_SUCCESS(Scanner->Initialize(g_Variables->Win32kBaseBaseAddress, ".text")))
	{
		Scanner->MakePattern("33 C0 48 39 05 ?? ?? ?? ?? 0F 95 C0 C3");
		Scanner->Scan();

		Result = Scanner->GetScanResult();
		Log("%p", *Result);
	}
	delete(Scanner);
}

VOID ShDrvExample::SocketTest(
	IN PCSTR IPv4Address, 
	IN PCSTR Path, 
	IN PCSTR Url, 
	IN PCSTR PostData, 
	IN SH_REQUEST_METHOD Method)
{
	PWSK_SOCKET Socket = nullptr;
	SH_SOCKET_SEND SendData = { 0, };
	SH_SOCKET_RECV RecvData = { 0, };

	RecvData.ReceiveBuffer = ALLOC_POOL(NONE_SPECIAL);

	SendData.IPv4Address = reinterpret_cast<PSTR>(ALLOC_POOL(ANSI_POOL));
	SendData.Url = reinterpret_cast<PSTR>(ALLOC_POOL(ANSI_POOL));
	SendData.Path = reinterpret_cast<PSTR>(ALLOC_POOL(ANSI_POOL));
	SendData.Optional = reinterpret_cast<PSTR>(ALLOC_POOL(ANSI_POOL));
	SendData.PostData = reinterpret_cast<PSTR>(ALLOC_POOL(ANSI_POOL));
	SendData.ConetentLength = reinterpret_cast<PSTR>(ALLOC_POOL(ANSI_POOL));
	SendData.Port = 80;

	StringCopy(SendData.IPv4Address, IPv4Address);
	StringCopy(SendData.Path, Path);
	StringCopy(SendData.Url, Url);
	StringCopy(SendData.PostData, PostData);
	RtlStringCchPrintfA(SendData.ConetentLength, NTSTRSAFE_MAX_LENGTH, "%lld", StringLength(SendData.PostData));

	ShSocketAPI::WskStartup();

	switch (Method)
	{
	case GET:
	{
		ShSocketAPI::Request(&SendData, &RecvData, GET);
		break;
	}
	case POST:
	{
		ShSocketAPI::Request(&SendData, &RecvData, POST);
		break;
	}
	default:
	{

	}
	}

	ShSocketAPI::WskCleanup();

	FREE_POOL(SendData.IPv4Address);
	FREE_POOL(SendData.Url);
	FREE_POOL(SendData.Path);
	FREE_POOL(SendData.Optional);
	FREE_POOL(SendData.PostData);
	FREE_POOL(SendData.ConetentLength);
}